# Algorithm_1💡

# 알고리즘

> 문제를 해결하기 위한 절차나 방법
> 

## 알고리즘 표현 방법

- 의사 코드(슈도 코드, Pseudo code)와 순서도
    - 최근에는 주로 의사 코드만 사용

## 좋은 알고리즘이란?

1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가

## 어떤 알고리즘을 사용해야 하는가?

- 알고리즘의 성능 분석 필요
- 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.
    - 작업량은 시간 복잡도로 표현
        - 시간 복잡도(Time Complexity)
            - 실행되는 명령문(연산)의 개수를 계산

# 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수(Coefficient)는 생략하여 표시

---

# 배열

## 배열이란?

> 일정한 자료형의 변수들을(연속적으로) 하나의 이름으로 열거하여 사용하는 자료구조
> 

## 배열의 필요성

- 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 배우 비효율적
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
- 단순히 다수의 변수 선언을 의미하는 것이 아닐, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

### 1차원 배열의 선언

- 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

```python
Array = [] # 데이터가 없지만 해당 메모리 주소를 참조할 준비를 한 상태
```

### 1차원 배열의 접근

```python
Array[index] = 1 # 배열 Array의 index에 1을 저장해라
```

---

# 정렬

## 정렬이란?

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열 하는 것
> 

## 정렬의 종류

- **버블 정렬 (Bubble Sort) : O(n**2)**
    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- **카운팅 정렬 (Counting Sort) : O(n+k)**
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- **선택 정렬 (Selection Sort)**
- **퀵 정렬 (Quick Sort)**
- **삽입 정렬 (Insertion Sort)**
- **병합 정렬 (Merge Sort)**

### 완전 검색

> 모든 경우의 수를 테스트한 후, 최종 해법을 도출. (Brute-force)라고도 불림
> 
- 수행 속도는 느리지만 해답을 찾을 확률이 높음

## 순열 (Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 다음과 같이 표현한다. → `nPr`
- 그리고 `nPr`은 다음과 같은 식이 성립한다.
    
    ```python
    nPr = n * (n-1) * (n-2) * ... * (n-r+1)
    ```
    

# 탐욕(Greedy) 알고리즘

> 최적해를 구하는 데 사용되는 근시안적인 방법
> 

## 동작 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인.
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인.
    1. 아직 전체 문제의 해가 완성되지 않았다면 1. 해 선택부터 다시 시작