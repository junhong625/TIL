# Algorithm_1💡

# 배열

## 배열이란?

> 일정한 자료형의 변수들을(연속적으로) 하나의 이름으로 열거하여 사용하는 자료구조

## 배열의 필요성

- 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 배우 비효율적
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
- 단순히 다수의 변수 선언을 의미하는 것이 아닐, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

## 인덱스

> Database에서 유래되어 테이블에 대한 동작 속도를 높여주는 자료 구조를 지칭
- 인덱스를 활용하면 더욱 빠르게 배열 내의 값에 접근 가능하다.

### 1차원 배열의 선언

- 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

```python
Array = [] # 데이터가 없지만 해당 메모리 주소를 참조할 준비를 한 상태
```

### 1차원 배열의 접근

```python
Array[index] = 1 # 배열 Array의 index에 1을 저장해라
```

## 순열 (Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 다음과 같이 표현한다. → `nPr`
- 그리고 `nPr`은 다음과 같은 식이 성립한다.
    
    ```python
    nPr = n * (n-1) * (n-2) * ... * (n-r+1)
    ```

---

# 2차원 배열

> 1차원 List를 묶어 놓은 List
> 
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
- 2차원 List의 선언 : 세로 길이(행의 개수), 가로 길이(열의 개수)를 필요로 함
- Python에서는 데이터 초기화를 통해 변수 선언과 초기화가 가능함

### 지그재그 순회

```python
for i in range(n):
		for j in range(m):
				Array[i][j + (m-1-2*j) * (i%2)]
```

## 델타를 이용한 2차 배열 탐색

> 2차원 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
> 

## 부분 집합

> 부분 집합의 개수 = 2 ** 원소 수(각 원소가 포함되는 경우, 포함되지 않는 경우)
> 

ex)

```python
bit = [0, 0, 0, 0] # 1, 2, 3, 4
for i in range(2):
		bit[0] = i
		for j in range(2):
				bit[1] = j
				for k in range(2):
						bit[2] = k
						for l in range(2):
								bit[3] = l
								arr.append(bit)
```

## 비트 연산자

- **`&`** : 비트 단위로 AND 연산을 한다.
- `|` : 비트 단위로 OR 연산을 한다.
- `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

## << 연산자

- 1 << n : 2**n 즉, 원소가 n개일 경우의 모든 부분 집합의 수를 의미

## & 연산자

- i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.
    - i의 j번째 비트가 0일 경우 0을 반환 1일 경우 0이 아닌 값을 반환

## Bit연산을 이용하여 부분 집합 생성

```python
arr = ['a', 'b', 'c']
N = len(arr)

for i in range(1, 1 << N):
    print(bin(i))
    for j in range(N):
        if i & (1 << j):
            print(arr[j], bin(1 << j), end=' ') # arr[j]가 부분집합, bin(i << j)는 좀 더
명확하게 이해하고자 넣은 코드
    print()
    print()
```

## 검색(Search)

> 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
> 
- 목적하는 탐색 키를 가진 항목을 찾는 것
    - 탐색 키(search key) : 자료를 구별하여 인식할 수 있는 키

## 검색의 종류

- 순차 검색(sequential search)
- 이진 검색(binary search)
- 해쉬(hash)

## 순차 검색

> 일렬로 되어 있는 자료를 순서대로 검색하는 방법
> 
- 가장 간단하고 직관적인 검색 방법
- 배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
- 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행 시간이 급격히 증가하여 비효율적임

### 두 가지 경우의 수

- 정렬 되어 있지 않은 경우 → O(n)
    - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하여 탐색
- 정렬 되어 있는 경우 → O(n)
    - 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 의미이므로 검색을 종료

## 이진 검색

> 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
> 
- 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
- 이진 검색을 하기 위해선 자료가 정렬된 상태!!

### 이진 검색 검색 과정

1. 자료의 중앙에 있는 원소 선택
2. 중앙 원소의 값과 목표 값을 비교
3. 각 조건에 맞는 작업을 수행
    - 중앙 원소의 값이 클 경우 → 왼쪽 반에 대해 검색을 수행
    - 중앙 원소의 값이 작을 경우 → 오른쪽 반에 대해 검색을 수행

> 목표 값을 찾을 때까지 위 과정들을 반복
> 

ex)

```python
def binarySearch(a, N, key):
		start = 0 # 시작
		end = N-1 # 끝
		while start <= end : # start가 end보다 커질 경우에는 종료
				middle = (start + end) // 2 # 중앙 값 설정
				if a[middle] == key: # 검색 성공일 경우
						return True
				elif a[middle] > key: # 목표 값보다 클 경우
						end = middle - 1 # 좌측 반을 검색
				else: # 목표 값보다 작을 경우
						start = middle + 1 # 우측 반을 검색
		return False # 검색 실패일 경우
```

