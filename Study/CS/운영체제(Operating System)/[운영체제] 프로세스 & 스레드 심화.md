## 프로세스의 자원 공유

기본적으로 각 프로세스는 별도의 메모리 주소 공간에서 실행되기에, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 하지만 아래와 같은 특별한 방법을 통해 프로세스 간 정보 공유는 가능하다.

1. IPC(Inter-Process Communication)
2. LPC(Local-Process Communication)
3. 별도로 공유 메모리를 만들어 정보를 주고받도록 설정

하지만 이러한 자원 공유는 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 자원 부담이 크다는 단점이 존재한다. 그래서 **다중 작업이 필요한 경우 스레드를 이용하는 것이 훨씬 효율적**이다.

---

## 스레드의 자원 공유

스레드는 **프로세스가 할당 받은 자원을 이용하는 실행의 단위**로서, 스레드가 여러개 있으면 파일을 다운 받으며 동시에 웹 서핑을 할 수 있게 해준다. 스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업이 가능한 것이다.

프로세스의 4가지 메모리 영역(Code, Data, Stack, Heap) 중 스레드는 Stack만 할당받아 복사하고 Code, Data, Heap은 프로세스 내의 다른 스레드와 공유한다. 

→ 따라서 각각의 스레드는 별도의 Stack을 가지고 있지만 Heap 메모리는 고유하기 때문에 서로 다른 스레드에서 가져와 읽고 쓸 수 있게 된다.

```markdown
❗stack은 지역 변수, 함수 호출 시 전달되는 인자, 되돌아갈 주소 값 저장하는 메모리 공간이기 때문에
독립적인 스택을 가졌다는 것은 **독립적인 함수 호출이 가능하다** 라는 의미이다.
그리고 독립적인 함수 호출이 가능하다는 것은 **독림적인 실행 흐름이 추가된다**는 의미이다.
```

> 이렇게 구성함으로써 하나의 프로세스를 다수의 실행 단위인 스레드로 구분하여 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소하하여      수행 능력을 향상 시켰다.
> 

---

## 프로세스와 스레드의 차이점

**프로세스** - 자신만의 **고유** 공간과 자원을 할당받아 사용(독립적)

**스레드** - 다른 스레드와 stack을 제외한 나머지 공간과 자원을 **공유**하면서 사용

위와 같은 차이점으로 인해 스레드는 프로세스보다 빠르게 Context Switching 작업이 가능하다.

```markdown
Context Switching이란?

cpu에서 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스의 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업을 Context Switching이라 한다.

```

---

# ❓스레드를 많이 쓰면 성능이 높아질까?

**무조건 좋다고 말할 수 없다!** 왜냐하면 고려해야할 사항들이 있기 때문이다.

### 1. 임계 영역에 대한 동기화 비용

```markdown
❗임계 영역(Critical Section)이란?

멀티 스레드 프로그래밍에서 임계 영역은 공유 자원을 접근하는 코드 영역을 말한다.
대표적으로 전역 변수나 heap 메모리 영역이 있다.
```

멀티 스레드는 같은 프로세스의 내의 스레드끼리 **자원을 공유한다**

→ 프로세스에 비해 적은 메모리와 자원을 소모

→ 컨텍스트 스위칭이 멀티 프로세스에 비해 빠르다.

→ 하지만, 여러 개의 스레드가 임계 영역에 접근할 수 있기 때문에 데이터의 일관성과 정확성을 위해 **동기화 기법(Synchronized)**을 사용해야 한다.

대표적인 동기화 기법

- Mutex
    
    > 공유 자원에 대해 접근 할 수 있는 Key🔑가 존재해야 접근이 가능하도록 하는 상호배제 기법
    > 
- Semaphore
    
    > 스레드나 프로세스가 접근할 수 있는 수를 나타내는 값을 두어 값이 상호배제를 달성하는 기법
    > 

문제점

- 뮤텍스나 세마포어와 같은 동기화 기법을 사용하는 경우 스레드가 공유자원에 접근 시 락을 획득하고 데이터에 접근이 끝난 후에 락을 해제하는데 이 시간 동안 해당 공유자원에 접근하려는 스레드의 실행을 중지하거나 대기하게 만들어야 하기에 **프로그램의 성능이 저하**될 수 있다.
- 동시에 여러 스레드에서 공유하는 메모리나 데이터에 수정을 가하면 CPU캐시와 메모리 사이의 데이터 일관성 문제가 발생할 수 있다.

→ 동기화 및 캐시 일관성 작업으로 인해 병목이 일어나 성능이 떨어진다.

### 2. 컨텍스트 스위칭 오버헤드

문제점 

- 컨텍스트 스위칭 하는 과정에서 CPU시간과 자원을 소모하는데 스레드가 프로세스보다 비용이 적다곤 하나 스레드가 많으면 많을수록 스위칭 횟수도 많아지고 덩달아 오버헤드도 많아져 성능이 저하될 수 있다.

예시

- 단일 스레드에서 1부터 1억까지 덧셈을 100번 반복
- 1000초

```java
long sum = 0;
for(int i=1; i<=100; i++){
	for(int j=1; j<=100000000; j++){
		sum += 1;
	}
}
```

- 100개의 스레드에서 1부터 1억까지 덧셈
- 10초

```java
long sum = 0;

/* 스레드 1번 */ 
new Thread(() -> {
	for(int i=1; i <= 100000000; i++){
		sum += 1;
	}
}).start();

/* 스레드 2번 */ 
new Thread(() -> {
	for(int i=1; i <= 100000000; i++){
		sum += 1;
	}
}).start();
.
.
.

/* 스레드 100번 */
new Thread(() -> {
	for(int i=1; i <= 100000000; i++){
		sum += 1;
	}
}).start();
// 100개의 스레드에서 동시 작업
```

### 3. 잔여스레드의 리소스 낭비

문제점

- 많은 양의 작업을 여러 개의 스레드들이 빠르게 처리해준다는 멀티 스레드의 취지는 좋지만 적은 개수의 스레드만 사용하는 경우 놀고 있는 잔여 스레드들이 불필요한 자원 점유로 인해 성능 저하가 될 수 있다.
- CPU는 다른 스레드에게 CPU 시간을 양도하도록 설계되어 있기 때문에 노는 스레드도 Context Switching을 하여 CPU의 효율성을 저하 시킨다.

→ 이러한 문제점들을 해결하기 위해 스레드 풀(Thread Pool)과 같은 매커니즘을 사용하여 리소스 낭비를 최소화 

```java
❗스레드 풀이란?

동시에 여러 작업을 효율적으로 실행 및 관리하기 위해 서버에서 만드는 스레드의 모음이다.
스레드 풀을 이용하면 각 작업에 대해 새 스레드를 생성하는 대신 이미 생성된 스레드 풀에 있는 스레드를 재사용한다..
이는 성능과 리소스 관리에 도움이 된다.
```

### 4. 어플리케이션의 성격에 따른 제약

문제점

- 개발하는 어플리케이션의 동작이 순차적으로 실행돼야만 하는 경우 다중 스레드를 사용할 경우 오히려 컨텍스트 스위칭으로 인한 비용과 시간이 증가될 수 있다.

→ 이에 대한 적절한 예시로 **CPU 바운드 어플리케이션 &** **IO 바운드 어플리케이션**, **GUI 어플리케이션**이 있다.

```markdown
❗ CPU 바운드 어플리케이션

CPU를 많이 사용하는 어플리케이션!
-> CPU를 많이 쓰기 때문에 코어보다 많은 수준 이상으로 스레드를 늘려봤자 별 이점이 없고 오히려 
컨텍스트 스위칭으로 인해 오버헤드 증가

❗IO 바운드 어플리케이션

입출력 작업이 많은 어플리케이션!
-> IO 작업은 하드웨어 한계상 상대적으로 작업에 시간이 걸림으로써 발생하는 대기 시간을 줄이기 위해
싱글 스레드가 아닌 멀티 스레드가 더욱 효율적

❗GUI 어플리케이션

그래픽 인터페이스를 통해 상호작용하는 어플리케이션
-> 순차적으로 실행되야만 하는 케이스로 상호작용된 순서대로 이벤트 처리 순서가 이루어져야 하기 때문에 
싱글 스레드를 사용하는 것이 안정적
```

### 5. 프로그래밍 난이도

문제점

- 멀티 스레드가 싱글 스레드보다 성능이 뛰어난건 맞지만 **스레드 간의 동기화 처리, 스레드 관리 미숙으로 인한 메모리 누수, 데드락**과 같은 문제에 대해 처리해야 하기에 개발 난이도가 높다.
- 이를 해결하지 못한다면 안정성과 유지보수성을 저해할 수 있다.