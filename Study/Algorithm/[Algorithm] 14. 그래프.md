# 그래프

> 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현
> 
- 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이하다.

## 그래프 유형

### 무방향 그래프(Undirected Graph)

- 각 정점들이 양방향으로 이동할 수 있는 그래프

### 유방향 그래프(Directed Graph)

- 각 정점에서 이동할 수 있는 방향이 정해져 있는 그래프

### 가중치 그래프(Weighted Graph)

- 각 정점에서 인접 정점으로 이동하는데 가중치가 드는 그래프

### 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)

- 시작 지점으로 다시 돌아오지 않는 방향 그래프

### 완전 그래프

- 정점들에 대해 가능한 모든 간선들을 가진 그래프

### 부분 그래프

- 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

## 인접 정점

### 인접(Adjacency)

- 두 개의 정점에 간선이 존재(연결)하면 서로 인접해 있다고 한다.
- 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다.

## 그래프 경로

- 경로란 간선들을 순서대로 나열한 것
- 경로 중 한 정점을 최대한 한번만 지나는 경로를 **단순 경로라 한다.**
    - ex) 0 - 2 - 4 - 6, 0 - 1- 6
- 시작한 정점에서 끝나는 경로를 **싸이클(Cycle)**이라고 한다.
    - ex) 1 - 3 - 5 - 1

## 그래프 표현

### 인접 행렬(Adjacent matrix)

- |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
- 배열의 배열(포인터 배열)
- 무방향 그래프는 대칭
- 예시) (0 - 1, 2, 3, 1 - 2, 3)의 유방향 그래프
    
    
    |  | 0(도착) | 1 | 2 | 3 |
    | --- | --- | --- | --- | --- |
    | 0(출발) | 0 | 1 | 1 | 1 |
    | 1 | 0 | 0 | 1 | 1 |
    | 2 | 0 | 0 | 0 | 0 |
    | 3 | 0 | 0 | 0 | 0 |
- 단점
    - 1000개를 넘는 노드가 존재한다면 인접 행렬을 생성할 수 없다.

### 인접 리스트(Adjacent List)

- 각 정점마다 해당 점점으로 나가는 간선의 정보를 저장

### 간선의 배열

- 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

## DFS로 그래프 풀이

> 지금까지와 다르게 **갈림길 저장**을 이용하는 DFS방식으로 풀이
> 
- 지나간 정점을 모두 저장하게 되면 중복 방문하는 노드가 발생
- 갈림길을 저장하며 방문 처리를 하게 되면 중복 방문 X
- `append`와 `pop`을 사용하는 것보다 `top`포인터를 이용하여 풀이를 하면 더욱 빠른 풀이 가능
- 인접 행렬과 갈림길 저장을 이용한 풀이

```python
def dfs(v):
    result = []
    stack = [v] + [0 for _ in range(len(edges))]
    top = 0
    visited = [0 for _ in range(len(edges)//2+1)]
    while top != -1:
        v = stack[top]
        top -= 1
        if not visited[v]:
            result.append(v)
            visited[v] = 1
            # for w in range(len(adjM[v])-1,-1,-1): # 오름차순 탐색
            for w in range(0, len(adjM)):           # 내림차순 탐색
                if adjM[v][w]:
                    top += 1
                    stack[top] = w
    return result
        
edges = list(map(int, input().split()))
adjM = [[0 for _ in range(len(edges)//2+1)] for _ in range(len(edges)//2+1)]
for i in range(0, len(edges), 2):                        # 인접 행렬
    adjM[edges[i]][edges[i+1]] = 1
    adjM[edges[i+1]][edges[i]] = 1

print(dfs(1))


'''ex) 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
오름차순 탐색 결과 - [1, 2, 4, 6, 5, 7, 3]
내림차순 탐색 결과 - [1, 3, 7, 6, 5, 2, 4]'''
``` 