# APS의 응용2

# 반복(Itertaion)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업을 수행 가능
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
    - 루프 (for, while구조)
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
    - 하나의 큰 문제를 작은 문제로 쪼개고 결과들을 결합

## 반복 구조

- 초기화
    - 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사
- 반복할 명령문 실행
- 업데이트
    - 무한 루프가 되지 않게 조건이 거짓이 되게 한다.

## 재귀 함수(recursive function)

- 함수 내부에서 직접 혹은 간적접으로 자기 자신을 호출하는 함수
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현
    - 따라서, 기본 부분(basic part)와 유도 부분(inductive part)로 구성됨
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 쉬움
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용
    - 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능 저하가 발생

### 팩토리얼 재귀 함수

- 재귀적 정의
    - Basic Rule : `n ≤ 1`경우 , `n = 1`
    - Inductive Rule : `n > 1` 경우, `n! = n * (n-1)!`
- 예시
    
    ```python
    def fact(n):
        if n <= 1:        # Basic Part
            return 1
    
        else:
            return n * fact(n-1)    # Inductive part
    ```
    

## 반복? 재귀?

> 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
> 
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
- 일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 함
- **즉, 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**

## 반복과 재귀의 비교

|  | 재귀 | 반복 |
| --- | --- | --- |
| 종료 | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건 |
| 수행 시간 | (상대적) 느림 | 빠름 |
| 메모리 공간 | (상대적) 많이 사용 | 적게 사용 |
| 소스 코드 길이 | 짧고 간결 | 길다 |
| 소스 코드 형태 | 선택 구조(if, else) | 반복 구조(for, while) |
| 무한 반복 시 | 스택 오버플로우 | CPU를 반복해서 점유 |

# Brute-force

> 문제를 해결하기 위한 가장 간단하고 쉬운 접근법
> 
- 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간에 문제 해결을 할 수 있다.
- 문제에 포함된 자료의 크기가 작다면 유용
- 알고리즘의 효율성을 판단하기 위한 척도로 사용

## Brute-force 탐색 (sequential search)

- 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행
- 결과는 두 가지(탐색 성공, 탐색 실패)
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 
해답을 찾아내지 못할 확률이 적다.
- 이를 기반으로 그리기 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.
- 

```python
def SequentialSearch(A, k): # A = [0....n]
A[n] = k	
i = 0
	while A[i] != k:
		i += 1
	if i < n:
		return i
	else:
		return -1
```

## 완전 탐색

> 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것
> 
- 전형적으로 순열(permutation), 조합(combination), 부분집합(subset)과 같은 조합적 문제들 (Combination Problems)과 연관된다.
- 완전 탐색은 조합적 문제에 대한 brute-force 방법이다.
- **검정 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후 성능이 개선된 다른 알고리즘을 사용하여 해답을 확인하는 것이 바람직**

# 순열(Permutation)

> 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
> 
- 순열 수식
    - $nPr$ = n * (n - 1) * (n - 2) * … * (n - r + 1)
- $nPn$ = n!이라고 표기하며 Factorial이라고 부른다.
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.
- n개의 요소들에 대해서 n!개의 순열들이 존재
    - n > 12인 경우, 시간 복잡도가 폭발적으로 증가

## 순열 생성 방법

### 1. 간단한 반복을 통한 순열 생성 방법

- [1, 2, 3]이 주어졌을 때

```python
for i in range(1,4):
	for j in range(1,4):
		if j != i:
			for k in range(1,4):
				if k != i and k != j:
					print(i, j, k)
```

### 2. 재귀를 통한 순열 생성 방법

- [1, 2, 3]이 주어졌을 때

```python
def f(i, k):
	if i == k:
		print(p)
	else:
		for j in range(i, k):
			p[i], p[j] = p[j], p[i]
			f(i+1, k)
			p[i], p[j] = p[j], p[i]

p = [1, 2, 3]
f(0, 3)
```

### 3. N개 중 r개를 고르는 경우

```python
def f(i, k, r):
	if i == r:
		print(p)
	else:
		for j in range(k):
			if used[j] == 0 # a[j]가 사용되지 않았다면
			used[j] = 1 # a[j]를 사용됨으로 변경
			p[i] = a[j] # p[i]에 a[j]삽입
			f(i+1, k, r) # p[i+1]에 값을 삽입하러 이동
			used[j] = 0 # 다른 자리에서 다시 사용할 수 있도록 사용 해제

N = int(input())
r = int(input())
a = [i for i in range(1, N+1)]
used = [0] * N
p = [0] * N
f(0, N, r)

```

# 부분 집합

> 집합에 포함된 원소들을 선택
> 
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
- N개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 모든 부분 집합(power set)의 개수는 2^n개
    - 원소의 수가 증가하면 부분 집합의 개수는 지속적으로 증가

## 부분 집합 생성 방법

### 1. 바이너리 카운팅(Binary Counting)

- 사전적 순서로 정렬이 가능
- 원소 수에 해당하는 N개의 비트열을 이용한다.
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

```python
arr = list(map(int, input().split()))
n = len(arr)

for i in range(0, 1 << n): # 1 << n: 부분 집합의 개수
	for j in range(n): # 원소의 수만큼 반복
		if i & (1 << j): # i의 j번째 비트가 1이면 j번째 원소 출력
			print(arr[j], end=' ')
	print()
```

### 2. 재귀를 활용

```python
def f(i, k):
	if i == k:
		for j in range(k):
			if bit[j]:
				print(arr[j], end=' ')
		print()
	else:
		bit[i] = 0
		f(i+1, k)
		bit[i] = 1
		f(i+1, k)
		
arr = list(map(int, input().split()))
n = len(arr)

bit = [0] * n
f(0, n)
```

# 조합

> 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
> 
- 조합 수식
    - $nCr$ = $n! \over (n-r)! r!$
    - ㅈ
    - $nCr$ =  $n-1Cr-1 + n-1Cr$

## 조합 생성 방법

### 1. 재귀 호출

- n개에서 r개를 조합할 경우

```python
def nCr(n, r, s):
	if r == 0:
		print(*comb)
	else:
		for i in range(s, n-r+1):
			comb[r-1] = A[i]
			nCr(n, r-1, i+1)
```

### 2. 반복문을 활용

- 10개에서 3개를 조합할 경우

```python
N = 10
arr = list(map(int, input().split()))

for i in range(N-2):
	for j in range(i+1, N-1):
		for k in range(j+1, N):
			print(arr[i], arr[j], arr[k])
```

# 탐욕 알고리즘

> 주어진 선택지 중 가장 최적이라고 생각되는 것을 선택해 최종적인 해답을 구해내는 알고리즘
> 
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 한번 선택된 것은 번복하지 않는다.
    - 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 제한적인 문제들에 적용된다.
- 최적화 문제(optimization)란 가능한 해들 중에서 가장 좋은 해를 찾는 문제이다.

## 탐욕 알고리즘의 동작 과정

### 1. 해 선택

- 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.

### 2. 실행 가능성 검사

- 새로운 부분 해 집합이 실행 가능한 지를 확인한다.
- 문제의 제약 조건을 위반하지 않는 지를 검사한다.

### 3. 해 검사

- 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다.
- 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

# Knapsack

> 조합 최적화의 대표적인 문제
> 

## 문제 유형

### 1. 0-1 Knapsack

- 배낭에 물건을 통째로 담아야 하는 문제
- 물건을 쪼갤 수 없는 경우

### 2. Fractional Knapsack

- 물건을 부분적으로 담는 것이 허용되는 문제
- 물건을 쪼갤 수 있는 경우

## 0-1 Knapsack 해결 방법

### 1. 완전 탐색 방법

- 완전 검색으로 물건들의 집합 S에 대한 모든 부분 집합을 구한다.
- 부분 집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 무게가 가장 큰 집합을 선택
- 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가
    - 크기가 n인 부분합의 수 $2^n$

### 2. 탐욕적 방법

- 탐욕적 방법으로는 0-1 Knapsack은 해결이 어렵다.
- 하지만 Fractional Knapsack은 해결이 가능

## 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성(greedy choice property)
    - 탐욕적 선택은 최적해로 갈 수 있음을 보여라
- 최적 부분 구조(optimal substructure property)
    - 최적화 문제를 정형화하라
- `원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해` 임을 증명해라

## 탐욕 기법과 동적 계획법의 비교

| 탐욕 기법 | 동적 계획법 |
| --- | --- |
| 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택 → 지역 최적 선택(local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다. |
| 하위 문제를 풀기 전에 먼저 이루어진다. | 하위 문제가 우선 해결된다. |
| Top-down 방식 | Bottom-up 방식 |
| 일반적으로 빠르고 간결하다. | 좀 더 느리고 복잡하다. |

## 대표적인 탐욕 기법의 알고리즘들

| 알고리즘 | 목적 | 설명 |  |
| --- | --- | --- | --- |
| Prim | N개의 노드에 대한 최소 신장 트리(MST)를 찾는다. | 서브 트리를 확장하면서 MST를 찾는다. | 그래프 |
| Kruskal | N개의 노드에 대한 최소 신장 트리(MST)를 찾는다. | 싸이클이 없는 서브 그래프를 확장하면서 MST를 찾는다. | 그래프 |
| Dijkstra | 주어진 정점에서 다른 정점들에 대한 최단 경로를 찾는다. | 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음 정점을 반복해서 찾는다. | 그래프 |
| Huffman
tree & code | 문서의 압축을 위해 문자들의 빈도수에 따라 코드 값을 부여한다. | 출현 빈도가 낮은 문자부터 선택해서 이진 트리를 완성하고 코드 값을 부여한다. | 문제해결 |