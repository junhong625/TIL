# Algorithm_2💡

# 알고리즘

> 문제를 해결하기 위한 절차나 방법

## 알고리즘 표현 방법

- 의사 코드(슈도 코드, Pseudo code)와 순서도
    - 최근에는 주로 의사 코드만 사용

## 좋은 알고리즘이란?

1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가

## 어떤 알고리즘을 사용해야 하는가?

- 알고리즘의 성능 분석 필요
- 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.
    - 작업량은 시간 복잡도로 표현
        - 시간 복잡도(Time Complexity)
            - 실행되는 명령문(연산)의 개수를 계산

# 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수(Coefficient)는 생략하여 표시

# 정렬

## 정렬이란?

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열 하는 것
> 

## 정렬의 종류

- **버블 정렬 (Bubble Sort) : O(n^2)**
    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- **카운팅 정렬 (Counting Sort) : O(n+k)**
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- **선택 정렬 (Selection Sort) : O(N^2)**
    - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- **퀵 정렬 (Quick Sort)**
- **삽입 정렬 (Insertion Sort)**
- **병합 정렬 (Merge Sort)**

### 완전 검색

> 모든 경우의 수를 테스트한 후, 최종 해법을 도출. (Brute-force)라고도 불림
> 
- 수행 속도는 느리지만 해답을 찾을 확률이 높음

## 탐욕(Greedy) 알고리즘

> 최적해를 구하는 데 사용되는 근시안적인 방법

- 완전 탐색과 비슷한 알고리즘

### 동작 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인.
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인.
    1. 아직 전체 문제의 해가 완성되지 않았다면 1. 해 선택부터 다시 시작

## 버블 정렬

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 구현이 매우 간단하다

### 정렬 과정

1. 리스트의 처음부터 시작하여 현재 위치의 값보다 다음 값이 작을 경우 서로 교환
2. 리스트의 끝까지 반복 - 이렇게 할 경우 리스트 끝에 제일 큰 값이 정렬
- 방금 값이 정렬된 인덱스의 이전 인덱스까지 1, 2번 다시 진행
- (리스트 길이 - 1) 만큼 반복 

## 카운팅 정렬

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
    
- N이 비교적 작을 때 사용한다

## 선택 정렬(Selection Sort) → O(n2)

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
> 

### 정렬 과정

- 리스트에서 최소값을 찾는다.
- 그 값을 리스트 맨 앞에 위치한 값과 교환
- 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복

## 셀렉션 알고리즘(Selection Algorithm)

> 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
> 
- 교환의 횟수가 버블, 삽입 정렬보다 작다.

### 선택 과정

- 정렬 알고리즘을 이용하여 자료 정렬
- 원하는 순서에 있는 원소 가져오기 

